"""
DP?

1. 크고 복잡한 문제를 작은 문제들로 나눈다. (subproblem - 하위문제)
2. 하위 문제의 답을 계산한다.
    중복 계산해야 하는 하위 문제가 있다. (overlapping subproblem - 중복 하위 문제)
    한 번 계산한 결과는 메모리에 저장하여 재계산 하지 않도록 한다.
3. 하위 문제에 대한 답을 통해 원래 문제에 대한 답을 계산한다. (optimal substructure - 최적 부분 구조)
    최적 부분 구조: 하위 문제에서 구한 최적의 답이 합쳐진 큰 문제의 최적의 답을 구할 수 있는 구조

Top down(memorization)
- 재귀 사용 => 구현시간이 빠르다.
- 재귀풀이에서 중복되는 계산값을 저장하여(memoize) 동일한 함수 호출시에 재활용
- hashtable 또는 list에 계산 결과를 저장한다.

Bottom up(tabulation)
- 반복문 사용 => 실행 시간이 빠르다.
- 더 작은 subproblem에 대한 계산결과를 DP table에 저장하여 더 큰 문제의 계산에 활용한다.
- hashtable 또는 list에 계산 결과를 저장한다.

총 정리
DP: 크고 복잡한 문제를 작게 나누고, 중복되는 문제라면 한 번 계산한 결과값을
저장해놓고 재사용함으로써 문제를 효율적으로 해결하는 알고리즘이다.

문제 풀이: 특정한 문제를 완전 탐색 알고리즘으로 접근해보고, 시간복잡도가 너무 높다면
DP를 적용할 수 있는지 생각해보기
subproblem의 중복 여부를 판단하는것이 첫 번째 순서다.

구현 방법
1. 일단 재귀함수로 비효율적인 완전탐색 코드를 작성한다.
2. 중복되는 subproblem의 계산 결과를 저장(memoize)한다.
3. 탑다운 -> 바텀업으로 코드 전환을 고려한다.
"""
